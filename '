/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Proxy.cpp                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: guhernan <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/04/11 23:03:17 by guhernan          #+#    #+#             */
/*   Updated: 2022/04/14 16:30:12 by guhernan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../headers/proxy/Proxy.hpp"

// Should stay unaccessible
Proxy::Proxy()
	: _server(0, SOCK_STREAM), _clients(), _flags(), _poll_data(),
	_timeout(), _to_server() { }

Proxy::Proxy(const port_type &port)
	: _server(port, SOCK_STREAM), _clients(), _flags(), _poll_data(),
	_timeout(), _to_server() {
		this->init_flags();
		this->init_poll_args();
	}

Proxy::Proxy(const Proxy &source)
	: _server(source._server), _clients(source._clients),
	_flags(source._flags), _poll_data(source._poll_data),
	_timeout(source._timeout),  _to_server(source._to_server) { }

Proxy::~Proxy() { }

Proxy	&Proxy::operator=(const Proxy &source) {
	_server.end_connexion();
	_server = source._server;
	_clients = source._clients;
	_flags = source._flags;
	_poll_data = source._poll_data;
	_timeout = source._timeout;
	_to_server = source._to_server;
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//
void			Proxy::switch_on() {
	this->init_server_socket();
}

void			Proxy::switch_off() {
	this->end_all_connexions();
	this->_poll_data.clear();
	this->_to_server.clear();
}

void		Proxy::set_timeout(Proxy::milisecond_type timeout) {
	_timeout = timeout;
}


void			Proxy::queuing() {
	fd_type		server_fd = _server.get_fd();

	poll(_poll_data.data(), _poll_data.size(), _timeout);

	for (pollfd_type::iterator it = _poll_data.begin() ;
			it != _poll_data.end() ;
			++it) {
		if (it->revents == 0)
			continue;
		else if (it->fd == server_fd)
			_flags[it->revents]->handle_server(&_server);
		else {
			client_tree_type::iterator tmp = _clients.find(it->fd);
			if (tmp == _clients.end())
				std::clog << " -- [ERROR] Client not found. [" << it->fd << "] " << std::endl;
			else
				_flags[it->revents]->handle(tmp->second);
		}
	}
}

Proxy::api_type	Proxy::send_data() { return _to_server; }

void			Proxy::receive_data(const api_type &data) { }

//////////////////////////////////////////////////////////////////////////
// Private methodes

void		Proxy::end_all_connexions() {
}

void		Proxy::end_connexion() {
}

void	Proxy::init_flags() {
	_flags.insert(std::make_pair(POLLIN, new Poll_in()));
	_flags.insert(std::make_pair(POLLPRI, new Poll_priority_in()));
	_flags.insert(std::make_pair(POLLNVAL, new Poll_invalid()));
	_flags.insert(std::make_pair(POLLHUP, new Poll_hang_up()));
	_flags.insert(std::make_pair(POLLERR, new Poll_error()));
}

void	Proxy::init_server_socket() {
	_server.create_endpoint();
	_server.bind_socket();
	_server.listen_for_connexion(); // set on 5 maximum requested connexion (default)
}

void	Proxy::init_poll_args() {
	struct pollfd	server_sock;

	bzero(&server_sock, sizeof(pollfd));
	server_sock.fd = _server.get_fd();
	server_sock.events = POLLIN;
	_poll_data.push_back(server_sock);
}

void		Proxy::update_flags() {
	fd_type		server_fd = _server.get_fd();

	// Iterate on pollfd array
	for (Proxy::pollfd_type::iterator it = _poll_data.begin() ;
			it != _poll_data.end() ; ++it)
		if (it->fd != server_fd) {
			// Check if there is messages waiting in the cache queue
			// FIXME it->events =
		}
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
// Poll classes

Proxy::APoll_handling::APoll_handling() {
}

Proxy::APoll_handling::~APoll_handling() {
}

void	Proxy::APoll_handling::handle(socket_type *socket) {
}
void	Proxy::APoll_handling::handle_server(socket_type *socket) {
}

//////////////////////////////////////////////////////////////////////////
// Poll_in : POLLIN

Proxy::Poll_in::Poll_in() {
}

Proxy::Poll_in::~Poll_in() {
}

void	Proxy::Poll_in::handle(socket_type *socket) {
}
void	Proxy::Poll_in::handle_server(socket_type *socket) {
}


//////////////////////////////////////////////////////////////////////////
// Priority_in : POLLPRI

Proxy::Poll_priority_in::Poll_priority_in() {
}

Proxy::Poll_priority_in::~Poll_priority_in() {
}

void	Proxy::Poll_priority_in::handle(socket_type *socket) {
}
void	Proxy::Poll_priority_in::handle_server(socket_type *socket) {
}

//////////////////////////////////////////////////////////////////////////
// Poll_invalid : POLLNVAL

Proxy::Poll_invalid::Poll_invalid() {
}

Proxy::Poll_invalid::~Poll_invalid() {
}

void	Proxy::Poll_invalid::handle(socket_type *socket) {
}
void	Proxy::Poll_invalid::handle_server(socket_type *socket) {
}

//////////////////////////////////////////////////////////////////////////
// Poll_hang_up : POLLHUP

Proxy::Poll_hang_up::Poll_hang_up() {
}

Proxy::Poll_hang_up::~Poll_hang_up() {
}

void	Proxy::Poll_hang_up::handle(socket_type *socket) {
}
void	Proxy::Poll_hang_up::handle_server(socket_type *socket) {
}

//////////////////////////////////////////////////////////////////////////
// Poll_error : POLLERR

Proxy::Poll_error::Poll_error() {
}

Proxy::Poll_error::~Poll_error() {
}

void	Proxy::Poll_error::handle(socket_type *socket) {
}
void	Proxy::Poll_error::handle_server(socket_type *socket) {
}

